{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#pgx-documentation","title":"Pgx Documentation","text":"<pre><code>import jax\nimport pgx\nenv = pgx.make(\"go_19x19\")\ninit = jax.jit(jax.vmap(env.init))  # vectorize and JIT-compile\nstep = jax.jit(jax.vmap(env.step))\nbatch_size = 1024\nkeys = jax.random.split(jax.random.PRNGKey(42), batch_size)\nstate = init(keys)  # vectorized states\nwhile not state.terminated.all():\naction = model(state.current_player, state.observation, state.legal_action_mask)\nstate = step(state, action)  # state.reward (2,)\n</code></pre>"},{"location":"api/","title":"API","text":"<p>This is the list of all public APIs of Pgx. Two important components in Pgx are <code>State</code> and <code>Env</code>.</p> <p>Naming convention of <code>EnvId</code></p> <p>Hyphen <code>-</code> is used to represent that there is a different original game source (e.g., <code>MinAtar</code>), and underscore <code>-</code> is used for the other cases.</p>"},{"location":"api/#pgx.State","title":"<code>pgx.State</code>","text":"<p>         Bases: <code>abc.ABC</code></p> <p>Base state class of all Pgx game environments. Basically an immutable (frozen) dataclass. A basic usage is generating via <code>Env.init</code>:</p> <pre><code>state = env.init(jax.random.PRNGKey(0))\n</code></pre> <p>and <code>Env.step</code> receives and returns this state class:</p> <pre><code>state = env.step(state, action)\n</code></pre> <p>Serialization via <code>flax.struct.serialization</code> is supported. There are 6 common attributes over all games:</p> <p>Attributes:</p> Name Type Description <code>current_player</code> <code>jnp.ndarray</code> <p>id of agent to play. Note that this does NOT represent the turn (e.g., black/white in Go). This ID is consistent over the parallel vmapped states.</p> <code>observation</code> <code>jnp.ndarray</code> <p>observation for the current state. <code>Env.observe</code> is called to compute.</p> <code>reward</code> <code>jnp.ndarray</code> <p>the <code>i</code>-th element indicates the intermediate reward for the agent with player-id <code>i</code>. If <code>Env.step</code> is called for a terminal state, the following <code>state.reward</code> is zero for all players.</p> <code>terminated</code> <code>jnp.ndarray</code> <p>denotes that the state is termianl state. Note that some environments (e.g., Go) have an <code>max_termination_steps</code> parameter inside and will terminates within a limited number of states (following AlphaGo).</p> <code>legal_action_mask</code> <code>jnp.ndarray</code> <p>Boolean array of legal actions. If illegal action is taken, the game will terminate immediately with the penalty to the palyer.</p> Source code in <code>pgx/v1.py</code> <pre><code>@dataclass\nclass State(abc.ABC):\n\"\"\"Base state class of all Pgx game environments. Basically an immutable (frozen) dataclass.\n    A basic usage is generating via `Env.init`:\n        state = env.init(jax.random.PRNGKey(0))\n    and `Env.step` receives and returns this state class:\n        state = env.step(state, action)\n    Serialization via `flax.struct.serialization` is supported.\n    There are 6 common attributes over all games:\n    Attributes:\n        current_player (jnp.ndarray): id of agent to play.\n            Note that this does NOT represent the turn (e.g., black/white in Go).\n            This ID is consistent over the parallel vmapped states.\n        observation (jnp.ndarray): observation for the current state.\n            `Env.observe` is called to compute.\n        reward (jnp.ndarray): the `i`-th element indicates the intermediate reward for\n            the agent with player-id `i`. If `Env.step` is called for a terminal state,\n            the following `state.reward` is zero for all players.\n        terminated (jnp.ndarray): denotes that the state is termianl state. Note that\n            some environments (e.g., Go) have an `max_termination_steps` parameter inside\n            and will terminates within a limited number of states (following AlphaGo).\n        legal_action_mask (jnp.ndarray): Boolean array of legal actions. If illegal action is taken,\n            the game will terminate immediately with the penalty to the palyer.\n    \"\"\"\ncurrent_player: jnp.ndarray\nobservation: jnp.ndarray\nreward: jnp.ndarray\nterminated: jnp.ndarray\nlegal_action_mask: jnp.ndarray\n# NOTE: _rng_key is\n#   - used for stochastic env and auto reset\n#   - updated only when actually used\n#   - supposed NOT to be used by agent\n_rng_key: jax.random.KeyArray\n_step_count: jnp.ndarray\n@property\n@abc.abstractmethod\ndef env_id(self) -&gt; EnvId:\n\"\"\"Environment id (e.g. \"go_19x19\")\"\"\"\n...\ndef _repr_html_(self) -&gt; str:\nreturn self.to_svg()\ndef to_svg(\nself,\n*,\ncolor_theme: Optional[Literal[\"light\", \"dark\"]] = None,\nscale: Optional[float] = None,\n) -&gt; str:\n\"\"\"Return SVG string. Useful for visualization in notebook.\n        Args:\n            color_theme (Optional[Literal[\"light\", \"dark\"]]): xxx see also global config.\n            scale (Optional[float]): change image size. Default(None) is 1.0\n        Returns:\n            str: SVG string\n        \"\"\"\nfrom pgx._src.visualizer import Visualizer\nv = Visualizer(color_theme=color_theme, scale=scale)\nreturn v.get_dwg(states=self).tostring()\ndef save_svg(\nself,\nfilename,\n*,\ncolor_theme: Optional[Literal[\"light\", \"dark\"]] = None,\nscale: Optional[float] = None,\n) -&gt; None:\n\"\"\"Save the entire state (not observation) to a file.\n        The filename must end with `.svg`\n        Args:\n            color_theme (Optional[Literal[\"light\", \"dark\"]]): xxx see also global config.\n            scale (Optional[float]): change image size. Default(None) is 1.0\n        Returns:\n            None\n        \"\"\"\nfrom pgx._src.visualizer import save_svg\nsave_svg(self, filename, color_theme=color_theme, scale=scale)\n</code></pre>"},{"location":"api/#pgx.v1.State.env_id","title":"<code>env_id: EnvId</code>  <code>abstractmethod</code> <code>property</code>","text":"<p>Environment id (e.g. \"go_19x19\")</p>"},{"location":"api/#pgx.v1.State.save_svg","title":"<code>save_svg(filename, *, color_theme=None, scale=None)</code>","text":"<p>Save the entire state (not observation) to a file. The filename must end with <code>.svg</code></p> <p>Parameters:</p> Name Type Description Default <code>color_theme</code> <code>Optional[Literal['light', 'dark']]</code> <p>xxx see also global config.</p> <code>None</code> <code>scale</code> <code>Optional[float]</code> <p>change image size. Default(None) is 1.0</p> <code>None</code> <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>pgx/v1.py</code> <pre><code>def save_svg(\nself,\nfilename,\n*,\ncolor_theme: Optional[Literal[\"light\", \"dark\"]] = None,\nscale: Optional[float] = None,\n) -&gt; None:\n\"\"\"Save the entire state (not observation) to a file.\n    The filename must end with `.svg`\n    Args:\n        color_theme (Optional[Literal[\"light\", \"dark\"]]): xxx see also global config.\n        scale (Optional[float]): change image size. Default(None) is 1.0\n    Returns:\n        None\n    \"\"\"\nfrom pgx._src.visualizer import save_svg\nsave_svg(self, filename, color_theme=color_theme, scale=scale)\n</code></pre>"},{"location":"api/#pgx.v1.State.to_svg","title":"<code>to_svg(*, color_theme=None, scale=None)</code>","text":"<p>Return SVG string. Useful for visualization in notebook.</p> <p>Parameters:</p> Name Type Description Default <code>color_theme</code> <code>Optional[Literal['light', 'dark']]</code> <p>xxx see also global config.</p> <code>None</code> <code>scale</code> <code>Optional[float]</code> <p>change image size. Default(None) is 1.0</p> <code>None</code> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>SVG string</p> Source code in <code>pgx/v1.py</code> <pre><code>def to_svg(\nself,\n*,\ncolor_theme: Optional[Literal[\"light\", \"dark\"]] = None,\nscale: Optional[float] = None,\n) -&gt; str:\n\"\"\"Return SVG string. Useful for visualization in notebook.\n    Args:\n        color_theme (Optional[Literal[\"light\", \"dark\"]]): xxx see also global config.\n        scale (Optional[float]): change image size. Default(None) is 1.0\n    Returns:\n        str: SVG string\n    \"\"\"\nfrom pgx._src.visualizer import Visualizer\nv = Visualizer(color_theme=color_theme, scale=scale)\nreturn v.get_dwg(states=self).tostring()\n</code></pre>"},{"location":"api/#pgx.Env","title":"<code>pgx.Env</code>","text":"<p>         Bases: <code>abc.ABC</code></p> <p>Environment class API.</p> <p>Example usage</p> <pre><code>env: Env = pgx.make(\"tic_tac_toe\")\nstate = env.init(jax.random.PRNGKey(0))\naction = jax.random.int32(4)\nstate = env.step(state, action)\n</code></pre> Source code in <code>pgx/v1.py</code> <pre><code>class Env(abc.ABC):\n\"\"\"Environment class API.\n    !!! example \"Example usage\"\n        ```py\n        env: Env = pgx.make(\"tic_tac_toe\")\n        state = env.init(jax.random.PRNGKey(0))\n        action = jax.random.int32(4)\n        state = env.step(state, action)\n        ```\n    \"\"\"\ndef __init__(self, *, auto_reset: bool = False):\nself.auto_reset = auto_reset\ndef init(self, key: jax.random.KeyArray) -&gt; State:\n\"\"\"Return the initial state. Note that no internal state of\n        environment changes.\n        Args:\n            key: pseudo-random generator key in JAX\n        Returns:\n            State: initial state of environment\n        \"\"\"\nkey, subkey = jax.random.split(key)\nstate = self._init(subkey)\nstate = state.replace(_rng_key=key)  # type: ignore\nobservation = self.observe(state, state.current_player)\nreturn state.replace(observation=observation)  # type: ignore\ndef step(self, state: State, action: jnp.ndarray) -&gt; State:\n\"\"\"Step function.\"\"\"\nis_illegal = ~state.legal_action_mask[action]\ncurrent_player = state.current_player\n# auto reset\nstate = jax.lax.cond(\nself.auto_reset &amp; state.terminated,\nlambda: state.replace(  # type: ignore\n_step_count=jnp.int32(0),\nterminated=FALSE,\nreward=jnp.zeros_like(state.reward),\n),\nlambda: state,\n)\n# If the state is already terminated or truncated, environment does not take usual step,\n# but return the same state with zero-rewards for all players\nstate = jax.lax.cond(\nstate.terminated,\nlambda: state.replace(reward=jnp.zeros_like(state.reward)),  # type: ignore\nlambda: self._step(state.replace(_step_count=state._step_count + 1), action),  # type: ignore\n)\n# Taking illegal action leads to immediate game terminal with negative reward\nstate = jax.lax.cond(\nis_illegal,\nlambda: self._step_with_illegal_action(state, current_player),\nlambda: state,\n)\n# All legal_action_mask elements are **TRUE** at terminal state\n# This is to avoid zero-division error when normalizing action probability\n# Taking any action at terminal state does not give any effect to the state\nstate = jax.lax.cond(\nstate.terminated,\nlambda: state.replace(  # type: ignore\nlegal_action_mask=jnp.ones_like(state.legal_action_mask)\n),\nlambda: state,\n)\nobservation = self.observe(state, state.current_player)\nstate = state.replace(observation=observation)  # type: ignore\n# auto reset\nstate = jax.lax.cond(\nself.auto_reset &amp; state.terminated,\n# state is replaced by initial state,\n# but preserve (terminated, truncated, reward)\nlambda: self.init(state._rng_key).replace(  # type: ignore\nterminated=state.terminated,\nreward=state.reward,\n),\nlambda: state,\n)\n# NOTE on final observation\n# When auto reset happened, the terminal (or truncated) observation is replaced by initial observation,\n# This is NOT problematic if it's termination.\n# However, when truncation happened, final observation might be used by agent (for bootstrap)\n# So we have to preserve the final observation somewhere. For example, in Gymnasium,\n#\n# https://github.com/Farama-Foundation/Gymnasium/blob/main/gymnasium/wrappers/autoreset.py#L59\n#\n# However, currently, truncation does **NOT** actually happens in Pgx environments because\n# all of Pgx environments (games) are finite-horizon and terminates within reasonable # of steps.\n# (NOTE: Chess, Shogi, and Go have `max_termination_steps` parameter following AlphaZero paper)\n# So we believe current implementation is sufficient (final observation is not necessary).\nreturn state\ndef observe(self, state: State, player_id: jnp.ndarray) -&gt; jnp.ndarray:\n\"\"\"Observation function.\"\"\"\nobs = self._observe(state, player_id)\nreturn jax.lax.stop_gradient(obs)\n@abc.abstractmethod\ndef _init(self, key: jax.random.KeyArray) -&gt; State:\n\"\"\"Implement game-specific init function here.\"\"\"\n...\n@abc.abstractmethod\ndef _step(self, state, action) -&gt; State:\n\"\"\"Implement game-specific step function here.\"\"\"\n...\n@abc.abstractmethod\ndef _observe(self, state: State, player_id: jnp.ndarray) -&gt; jnp.ndarray:\n\"\"\"Implement game-specific observe function here.\"\"\"\n...\n@property\n@abc.abstractmethod\ndef id(self) -&gt; EnvId:\n\"\"\"Environment id.\"\"\"\n...\n@property\n@abc.abstractmethod\ndef version(self) -&gt; str:\n\"\"\"Environment version. Updated when behavior, parameter, or API is changed.\n        Refactoring or speeding up without any expected behavior changes will NOT update the version number.\n        \"\"\"\n...\n@property\n@abc.abstractmethod\ndef num_players(self) -&gt; int:\n\"\"\"Number of players (e.g., 2 in Tic-tac-toe)\"\"\"\n...\n@property\ndef num_actions(self) -&gt; int:\n\"\"\"Return the size of action space (e.g., 9 in Tic-tac-toe)\"\"\"\nstate = self.init(jax.random.PRNGKey(0))\nreturn int(state.legal_action_mask.shape[0])\n@property\ndef observation_shape(self) -&gt; Tuple[int, ...]:\n\"\"\"Return the matrix shape of observation\"\"\"\nstate = self.init(jax.random.PRNGKey(0))\nobs = self._observe(state, state.current_player)\nreturn obs.shape\n@property\ndef _illegal_action_penalty(self) -&gt; float:\n\"\"\"Negative reward given when illegal action is selected.\"\"\"\nreturn -1.0\ndef _step_with_illegal_action(\nself, state: State, loser: jnp.ndarray\n) -&gt; State:\npenalty = self._illegal_action_penalty\nreward = (\njnp.ones_like(state.reward)\n* (-1 * penalty)\n* (self.num_players - 1)\n)\nreward = reward.at[loser].set(penalty)\nreturn state.replace(reward=reward, terminated=TRUE)  # type: ignore\n</code></pre>"},{"location":"api/#pgx.v1.Env.id","title":"<code>id: EnvId</code>  <code>abstractmethod</code> <code>property</code>","text":"<p>Environment id.</p>"},{"location":"api/#pgx.v1.Env.num_actions","title":"<code>num_actions: int</code>  <code>property</code>","text":"<p>Return the size of action space (e.g., 9 in Tic-tac-toe)</p>"},{"location":"api/#pgx.v1.Env.num_players","title":"<code>num_players: int</code>  <code>abstractmethod</code> <code>property</code>","text":"<p>Number of players (e.g., 2 in Tic-tac-toe)</p>"},{"location":"api/#pgx.v1.Env.observation_shape","title":"<code>observation_shape: Tuple[int, ...]</code>  <code>property</code>","text":"<p>Return the matrix shape of observation</p>"},{"location":"api/#pgx.v1.Env.version","title":"<code>version: str</code>  <code>abstractmethod</code> <code>property</code>","text":"<p>Environment version. Updated when behavior, parameter, or API is changed. Refactoring or speeding up without any expected behavior changes will NOT update the version number.</p>"},{"location":"api/#pgx.v1.Env.init","title":"<code>init(key)</code>","text":"<p>Return the initial state. Note that no internal state of environment changes.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>jax.random.KeyArray</code> <p>pseudo-random generator key in JAX</p> required <p>Returns:</p> Name Type Description <code>State</code> <code>State</code> <p>initial state of environment</p> Source code in <code>pgx/v1.py</code> <pre><code>def init(self, key: jax.random.KeyArray) -&gt; State:\n\"\"\"Return the initial state. Note that no internal state of\n    environment changes.\n    Args:\n        key: pseudo-random generator key in JAX\n    Returns:\n        State: initial state of environment\n    \"\"\"\nkey, subkey = jax.random.split(key)\nstate = self._init(subkey)\nstate = state.replace(_rng_key=key)  # type: ignore\nobservation = self.observe(state, state.current_player)\nreturn state.replace(observation=observation)  # type: ignore\n</code></pre>"},{"location":"api/#pgx.v1.Env.observe","title":"<code>observe(state, player_id)</code>","text":"<p>Observation function.</p> Source code in <code>pgx/v1.py</code> <pre><code>def observe(self, state: State, player_id: jnp.ndarray) -&gt; jnp.ndarray:\n\"\"\"Observation function.\"\"\"\nobs = self._observe(state, player_id)\nreturn jax.lax.stop_gradient(obs)\n</code></pre>"},{"location":"api/#pgx.v1.Env.step","title":"<code>step(state, action)</code>","text":"<p>Step function.</p> Source code in <code>pgx/v1.py</code> <pre><code>def step(self, state: State, action: jnp.ndarray) -&gt; State:\n\"\"\"Step function.\"\"\"\nis_illegal = ~state.legal_action_mask[action]\ncurrent_player = state.current_player\n# auto reset\nstate = jax.lax.cond(\nself.auto_reset &amp; state.terminated,\nlambda: state.replace(  # type: ignore\n_step_count=jnp.int32(0),\nterminated=FALSE,\nreward=jnp.zeros_like(state.reward),\n),\nlambda: state,\n)\n# If the state is already terminated or truncated, environment does not take usual step,\n# but return the same state with zero-rewards for all players\nstate = jax.lax.cond(\nstate.terminated,\nlambda: state.replace(reward=jnp.zeros_like(state.reward)),  # type: ignore\nlambda: self._step(state.replace(_step_count=state._step_count + 1), action),  # type: ignore\n)\n# Taking illegal action leads to immediate game terminal with negative reward\nstate = jax.lax.cond(\nis_illegal,\nlambda: self._step_with_illegal_action(state, current_player),\nlambda: state,\n)\n# All legal_action_mask elements are **TRUE** at terminal state\n# This is to avoid zero-division error when normalizing action probability\n# Taking any action at terminal state does not give any effect to the state\nstate = jax.lax.cond(\nstate.terminated,\nlambda: state.replace(  # type: ignore\nlegal_action_mask=jnp.ones_like(state.legal_action_mask)\n),\nlambda: state,\n)\nobservation = self.observe(state, state.current_player)\nstate = state.replace(observation=observation)  # type: ignore\n# auto reset\nstate = jax.lax.cond(\nself.auto_reset &amp; state.terminated,\n# state is replaced by initial state,\n# but preserve (terminated, truncated, reward)\nlambda: self.init(state._rng_key).replace(  # type: ignore\nterminated=state.terminated,\nreward=state.reward,\n),\nlambda: state,\n)\n# NOTE on final observation\n# When auto reset happened, the terminal (or truncated) observation is replaced by initial observation,\n# This is NOT problematic if it's termination.\n# However, when truncation happened, final observation might be used by agent (for bootstrap)\n# So we have to preserve the final observation somewhere. For example, in Gymnasium,\n#\n# https://github.com/Farama-Foundation/Gymnasium/blob/main/gymnasium/wrappers/autoreset.py#L59\n#\n# However, currently, truncation does **NOT** actually happens in Pgx environments because\n# all of Pgx environments (games) are finite-horizon and terminates within reasonable # of steps.\n# (NOTE: Chess, Shogi, and Go have `max_termination_steps` parameter following AlphaZero paper)\n# So we believe current implementation is sufficient (final observation is not necessary).\nreturn state\n</code></pre>"},{"location":"api/#pgx.EnvId","title":"<code>pgx.EnvId = Literal['2048', 'animal_shogi', 'backgammon', 'bridge_bidding', 'chess', 'connect_four', 'go_9x9', 'go_19x19', 'hex', 'kuhn_poker', 'leduc_holdem', 'minatar-asterix', 'minatar-breakout', 'minatar-freeway', 'minatar-seaquest', 'minatar-space_invaders', 'othello', 'shogi', 'sparrow_mahjong', 'tic_tac_toe']</code>  <code>module-attribute</code>","text":""},{"location":"api/#pgx.make","title":"<code>pgx.make(env_id, *, auto_reset=False)</code>","text":"<p>Load the specified environment.</p> <p>Example usage</p> <pre><code>env = pgx.make(\"tic_tac_toe\")\n</code></pre> <p><code>BridgeBidding</code> environment</p> <p><code>BridgeBidding</code> environment requires the domain knowledge of bridge game. So we forbid users to load the bridge environment by <code>make(\"bridge_bidding\")</code>. Use <code>BridgeBidding</code> class directly by <code>from pgx.bridge_bidding import BridgeBidding</code>.</p> Source code in <code>pgx/v1.py</code> <pre><code>def make(env_id: EnvId, *, auto_reset: bool = False):  # noqa: C901\n\"\"\"Load the specified environment.\n    !!! example \"Example usage\"\n        ```py\n        env = pgx.make(\"tic_tac_toe\")\n        ```\n    !!! note \"`BridgeBidding` environment\"\n        `BridgeBidding` environment requires the domain knowledge of bridge game.\n        So we forbid users to load the bridge environment by `make(\"bridge_bidding\")`.\n        Use `BridgeBidding` class directly by `from pgx.bridge_bidding import BridgeBidding`.\n    \"\"\"\n# NOTE: BridgeBidding environment requires the domain knowledge of bridge\n# So we forbid users to load the bridge environment by `make(\"bridge_bidding\")`.\nif env_id == \"2048\":\nfrom pgx.play2048 import Play2048\nreturn Play2048(auto_reset=auto_reset)\nelif env_id == \"animal_shogi\":\nfrom pgx.animal_shogi import AnimalShogi\nreturn AnimalShogi(auto_reset=auto_reset)\nelif env_id == \"backgammon\":\nfrom pgx.backgammon import Backgammon\nreturn Backgammon(auto_reset=auto_reset)\nelif env_id == \"chess\":\nfrom pgx.chess import Chess\nreturn Chess(auto_reset=auto_reset)\nelif env_id == \"connect_four\":\nfrom pgx.connect_four import ConnectFour\nreturn ConnectFour(auto_reset=auto_reset)\nelif env_id == \"go_9x9\":\nfrom pgx.go import Go\nreturn Go(auto_reset=auto_reset, size=9, komi=7.5)\nelif env_id == \"go_19x19\":\nfrom pgx.go import Go\nreturn Go(auto_reset=auto_reset, size=19, komi=7.5)\nelif env_id == \"hex\":\nfrom pgx.hex import Hex\nreturn Hex(auto_reset=auto_reset)\nelif env_id == \"kuhn_poker\":\nfrom pgx.kuhn_poker import KuhnPoker\nreturn KuhnPoker(auto_reset=auto_reset)\nelif env_id == \"leduc_holdem\":\nfrom pgx.leduc_holdem import LeducHoldem\nreturn LeducHoldem(auto_reset=auto_reset)\nelif env_id == \"minatar-asterix\":\nfrom pgx.minatar.asterix import MinAtarAsterix\nreturn MinAtarAsterix(auto_reset=auto_reset)\nelif env_id == \"minatar-breakout\":\nfrom pgx.minatar.breakout import MinAtarBreakout\nreturn MinAtarBreakout(auto_reset=auto_reset)\nelif env_id == \"minatar-freeway\":\nfrom pgx.minatar.freeway import MinAtarFreeway\nreturn MinAtarFreeway(auto_reset=auto_reset)\nelif env_id == \"minatar-seaquest\":\nfrom pgx.minatar.seaquest import MinAtarSeaquest\nreturn MinAtarSeaquest(auto_reset=auto_reset)\nelif env_id == \"minatar-space_invaders\":\nfrom pgx.minatar.space_invaders import MinAtarSpaceInvaders\nreturn MinAtarSpaceInvaders(auto_reset=auto_reset)\nelif env_id == \"othello\":\nfrom pgx.othello import Othello\nreturn Othello(auto_reset=auto_reset)\nelif env_id == \"shogi\":\nfrom pgx.shogi import Shogi\nreturn Shogi(auto_reset=auto_reset)\nelif env_id == \"sparrow_mahjong\":\nfrom pgx.sparrow_mahjong import SparrowMahjong\nreturn SparrowMahjong(auto_reset=auto_reset)\nelif env_id == \"tic_tac_toe\":\nfrom pgx.tic_tac_toe import TicTacToe\nreturn TicTacToe(auto_reset=auto_reset)\nelse:\navailable_envs = \"\\n\".join(available_games())\nraise ValueError(\nf\"Wrong env_id is passed. Available ids are: \\n{available_envs}\"\n)\n</code></pre>"},{"location":"api/#pgx.available_games","title":"<code>pgx.available_games()</code>","text":"<p>List up all environment id available in <code>pgx.make</code> function.</p> <p>Example usage</p> <pre><code>pgx.available_games()\n('2048', 'animal_shogi', 'backgammon', 'chess', 'connect_four', 'go_9x9', 'go_19x19', 'hex', 'kuhn_poker', 'leduc_holdem', 'minatar-asterix', 'minatar-breakout', 'minatar-freeway', 'minatar-seaquest', 'minatar-space_invaders', 'othello', 'shogi', 'sparrow_mahjong', 'tic_tac_toe')\n</code></pre> <p><code>BridgeBidding</code> environment</p> <p><code>BridgeBidding</code> environment requires the domain knowledge of bridge game. So we forbid users to load the bridge environment by <code>make(\"bridge_bidding\")</code>. Use <code>BridgeBidding</code> class directly by <code>from pgx.bridge_bidding import BridgeBidding</code>.</p> Source code in <code>pgx/v1.py</code> <pre><code>def available_games() -&gt; Tuple[EnvId, ...]:\n\"\"\"List up all environment id available in `pgx.make` function.\n    !!! example \"Example usage\"\n        ```py\n        pgx.available_games()\n        ('2048', 'animal_shogi', 'backgammon', 'chess', 'connect_four', 'go_9x9', 'go_19x19', 'hex', 'kuhn_poker', 'leduc_holdem', 'minatar-asterix', 'minatar-breakout', 'minatar-freeway', 'minatar-seaquest', 'minatar-space_invaders', 'othello', 'shogi', 'sparrow_mahjong', 'tic_tac_toe')\n        ```\n    !!! note \"`BridgeBidding` environment\"\n        `BridgeBidding` environment requires the domain knowledge of bridge game.\n        So we forbid users to load the bridge environment by `make(\"bridge_bidding\")`.\n        Use `BridgeBidding` class directly by `from pgx.bridge_bidding import BridgeBidding`.\n    \"\"\"\ngames = get_args(EnvId)\ngames = tuple(filter(lambda x: x != \"bridge_bidding\", games))\nreturn games\n</code></pre>"},{"location":"api/#pgx.set_visualization_config","title":"<code>pgx.set_visualization_config(*, color_theme='light', scale=1.0, frame_duration_seconds=0.2)</code>","text":"Source code in <code>pgx/_src/visualizer.py</code> <pre><code>def set_visualization_config(\n*,\ncolor_theme: ColorTheme = \"light\",\nscale: float = 1.0,\nframe_duration_seconds: float = 0.2,\n):\nglobal_config.color_theme = color_theme\nglobal_config.scale = scale\nglobal_config.frame_duration_seconds = frame_duration_seconds\n</code></pre>"},{"location":"api/#pgx.save_svg","title":"<code>pgx.save_svg(states, filename, *, color_theme=None, scale=None)</code>","text":"Source code in <code>pgx/_src/visualizer.py</code> <pre><code>def save_svg(\nstates: State,\nfilename: Union[str, Path],\n*,\ncolor_theme: Optional[Literal[\"light\", \"dark\"]] = None,\nscale: Optional[float] = None,\n) -&gt; None:\nassert str(filename).endswith(\".svg\")\nv = Visualizer(color_theme=color_theme, scale=scale)\nv.get_dwg(states=states).saveas(filename)\n</code></pre>"},{"location":"api/#pgx.save_svg_animation","title":"<code>pgx.save_svg_animation(states, filename, *, color_theme=None, scale=None, frame_duration_seconds=None)</code>","text":"Source code in <code>pgx/_src/visualizer.py</code> <pre><code>def save_svg_animation(\nstates: Sequence[State],\nfilename: Union[str, Path],\n*,\ncolor_theme: Optional[Literal[\"light\", \"dark\"]] = None,\nscale: Optional[float] = None,\nframe_duration_seconds: Optional[float] = None,\n) -&gt; None:\nassert str(filename).endswith(\".svg\")\nv = Visualizer(color_theme=color_theme, scale=scale)\nif frame_duration_seconds is None:\nframe_duration_seconds = global_config.frame_duration_seconds\nframe_groups = []\ndwg = None\nfor i, state in enumerate(states):\ndwg = v.get_dwg(states=state)\nassert (\nlen(\n[\ne\nfor e in dwg.elements\nif type(e) == svgwrite.container.Group\n]\n)\n== 1\n), \"Drawing must contain only one group\"\ngroup: svgwrite.container.Group = dwg.elements[-1]\ngroup[\"id\"] = f\"_fr{i:x}\"  # hex frame number\ngroup[\"class\"] = \"frame\"\nframe_groups.append(group)\nassert dwg is not None\ndel dwg.elements[-1]\ntotal_seconds = frame_duration_seconds * len(frame_groups)\nstyle = f\".frame{{visibility:hidden; animation:{total_seconds}s linear _k infinite;}}\"\nstyle += f\"@keyframes _k{{0%,{100/len(frame_groups)}%{{visibility:visible}}{100/len(frame_groups) * 1.000001}%,100%{{visibility:hidden}}}}\"\nfor i, group in enumerate(frame_groups):\ndwg.add(group)\nstyle += (\nf\"#{group['id']}{{animation-delay:{i * frame_duration_seconds}s}}\"\n)\ndwg.defs.add(svgwrite.container.Style(content=style))\ndwg.saveas(filename)\n</code></pre>"},{"location":"api/#pgx.v1_api_test","title":"<code>pgx.v1_api_test(env, num=100)</code>","text":"Source code in <code>pgx/_src/api_test.py</code> <pre><code>def v1_api_test(env: Env, num: int = 100):\napi_test_single(env, num)\napi_test_batch(env, num)\n</code></pre>"},{"location":"connect_four/","title":"Connect four","text":"darklight <p><p> </p></p> <p><p> </p></p>"},{"location":"connect_four/#usage","title":"Usage","text":"<pre><code>import pgx\nenv = pgx.make(\"connect_four\")\n</code></pre> <p>or you can directly load <code>ConnectFour</code> class</p> <pre><code>from pgx.connect_four import ConnectFour\nenv = ConnectFour()\n</code></pre>"},{"location":"connect_four/#description","title":"Description","text":"<p>Connect Four is a two-player connection rack game, in which the players choose a color and then take turns dropping colored tokens into a seven-column, six-row vertically suspended grid. The pieces fall straight down, occupying the lowest available space within the column. The objective of the game is to be the first to form a horizontal, vertical, or diagonal line of four of one's own tokens.</p> <p>Wikipedia</p>"},{"location":"connect_four/#specs","title":"Specs","text":"Name Value Version <code>v0</code> Number of players <code>2</code> Number of actions <code>7</code> Observation shape <code>(6, 7, 2)</code> Observation type <code>bool</code> Rewards <code>{-1, 0, 1}</code>"},{"location":"connect_four/#observation","title":"Observation","text":"Index Description <code>[:, :, 0]</code> represents <code>(6, 7)</code> squares filled by the current player <code>[:, :, 1]</code> represents <code>(6, 7)</code> squares filled by the opponent player of current player"},{"location":"connect_four/#action","title":"Action","text":"<p>Each action represents the column index the player drops the token to.</p>"},{"location":"connect_four/#rewards","title":"Rewards","text":"<p>Non-zero rewards are given only at the terminal states. The reward at terminal state is described in this table:</p> Reward Win <code>+1</code> Lose <code>-1</code> Draw <code>0</code>"},{"location":"connect_four/#termination","title":"Termination","text":"<p>Termination happens when </p> <ol> <li>either one player places four of their tokens in a row (horizontally, vertically, or diagonally), or </li> <li>all <code>42 (= 6 x 7)</code> squares are filled.</li> </ol>"},{"location":"connect_four/#version-history","title":"Version History","text":"<ul> <li><code>v0</code> : Initial release (v1.0.0)</li> </ul>"},{"location":"go/","title":"Go","text":"darklight <p><p> </p></p> <p><p> </p></p>"},{"location":"go/#usage","title":"Usage","text":"<pre><code>import pgx\nenv = pgx.make(\"go_19x19\")  # or \"go_9x9\"\n</code></pre> <p>or you can directly load <code>Go</code> class</p> <pre><code>from pgx.go import Go\nenv = Go(size=19, komi=6.5)\n</code></pre>"},{"location":"go/#description","title":"Description","text":"<p>Go is an abstract strategy board game for two players in which the aim is to surround more territory than the opponent. The game was invented in China more than 2,500 years ago and is believed to be the oldest board game continuously played to the present day.</p> <p>Wikipedia</p>"},{"location":"go/#rules","title":"Rules","text":"<p>The rule implemented in Pgx follows Tromp-Taylor Rules.</p> <p>Komi</p> <p>By default, we use <code>6.5</code>. Users can set different <code>komi</code> at <code>Go</code> class constructor.</p> <p>Ko</p> <p>On PSK implementations.</p> <p>Tromp-Taylor rule employ PSK. However, implementing strict PSK is inefficient because</p> <ul> <li>Simulator has to store all previous board (or hash) history, and</li> <li>Agent also has to remember all previous board to avoid losing by PSK</li> </ul> <p>As PSK rarely happens, as far as our best knowledge, it is usual to compromise in PSK implementations. For example,</p> <ul> <li>OpenSpiel employs SSK (instead of PSK) for computing legal actions, and if PSK action happened, the game ends with tie.<ul> <li>Pros: Detect all PSK actions</li> <li>Cons: Agent cannot know why the game ends with tie (if the same board is too old)</li> </ul> </li> <li>PettingZoo employs SSK for legal actions, and ignores even if PSK action happened.<ul> <li>Pros: Simple</li> <li>Cons: PSK is totally ignored</li> </ul> </li> </ul> <p>Note that the strict rule is \"PSK for legal actions, and PSK action leads to immediate lose.\" So, we also compromise at this point, our approach is</p> <ul> <li>Pgx employs SSK for legal actions, PSK is approximated by up to 8-steps before board, and approximate PSK action leads to immediate lose<ul> <li>Pros: Agent may be able to avoid PSK (as it observes board history up to 8-steps in AlphaGo Zero feature)</li> <li>Cons: Ignoring the old same boards</li> </ul> </li> </ul> <p>Anyway, we believe it's effect is very small as PSK rarely happens, especially in 19x19 board.</p>"},{"location":"go/#specs","title":"Specs","text":"<p>Let <code>N</code> be the board size (e.g., <code>19</code>).</p> Name Value Version <code>v0</code> Number of players <code>2</code> Number of actions <code>N x N + 1</code> Observation shape <code>(N, N, 17)</code> Observation type <code>bool</code> Rewards <code>{-1, 0, 1}</code>"},{"location":"go/#observation","title":"Observation","text":"<p>We follow the observation design of AlphaGo Zero <code>[Silver+17]</code>.</p> Index Description <code>obs[:, :, 0]</code> stones of <code>player_id</code>          (@ current board) <code>obs[:, :, 1]</code> stones of <code>player_id</code>'s opponent (@ current board) <code>obs[:, :, 2]</code> stones of <code>player_id</code>          (@ 1-step before) <code>obs[:, :, 3]</code> stones of <code>player_id</code>'s opponent (@ 1-step before) ... ... <code>obs[:, :, -1]</code> color of <code>player_id</code> <p>Final observation dimension</p> <p>For the final dimension, there are two possible options:</p> <ul> <li>Use the color of current player to play</li> <li>Use the color of <code>player_id</code></li> </ul> <p>This ambiguity happens because <code>observe</code> function is available even if <code>player_id</code> is different from <code>state.current_player</code>. In AlphaGo Zero paper <code>[Silver+17]</code>, the final dimension C is explained as:</p> <p>The final feature plane, C, represents the colour to play, and has a constant value of either 1 if black     is to play or 0 if white is to play.</p> <p>however, it also describes as</p> <p>the colour feature C is necessary because the komi is not observable.</p> <p>So, we use player_id's color to let the agent know komi information. As long as it's called when <code>player_id == state.current_player</code>, this doesn't matter.</p>"},{"location":"go/#action","title":"Action","text":"<p>Each action (<code>{0, ..., N * N - 1}</code>) represents the point to be colored. The final action represents pass action.</p>"},{"location":"go/#rewards","title":"Rewards","text":"<p>Non-zero rewards are given only at the terminal states. The reward at terminal state is described in this table:</p> Reward Win <code>+1</code> Lose <code>-1</code> Draw <code>0</code>"},{"location":"go/#termination","title":"Termination","text":"<p>Termination happens when </p> <ol> <li>either one plays two consecutive passes, or</li> <li><code>N * N * 2</code> steps are elapsed <code>[Silver+17]</code>.</li> </ol>"},{"location":"go/#version-history","title":"Version History","text":"<ul> <li><code>v0</code> : Initial release (v1.0.0)</li> </ul>"},{"location":"go/#reference","title":"Reference","text":"<ol> <li><code>[Silver+17]</code> \"Mastering the game of go without human knowledge\" Nature</li> </ol>"},{"location":"hex/","title":"Hex","text":"darklight <p><p> </p></p> <p><p> </p></p>"},{"location":"hex/#usage","title":"Usage","text":"<pre><code>import pgx\nenv = pgx.make(\"hex\")\n</code></pre> <p>or you can directly load <code>Hex</code> class</p> <pre><code>from pgx.hex import Hex\nenv = Hex()\n</code></pre>"},{"location":"hex/#description","title":"Description","text":"<p>Hex is a two player abstract strategy board game in which players attempt to connect opposite sides of a rhombus-shaped board made of hexagonal cells. Hex was invented by mathematician and poet Piet Hein in 1942 and later rediscovered and popularized by John Nash.</p> <p>Wikipedia</p>"},{"location":"hex/#specs","title":"Specs","text":"Name Value Version <code>v0</code> Number of players <code>2</code> Number of actions <code>121 (= 11 x 11)</code> Observation shape <code>(11, 11, 2)</code> Observation type <code>bool</code> Rewards <code>{-1, 1}</code>"},{"location":"hex/#observation","title":"Observation","text":"Index Description <code>[:, :, 0]</code> represents <code>(11, 11)</code> cells filled by the current player <code>[:, :, 1]</code> represents <code>(11, 11)</code> cells filled by the opponent player of current player"},{"location":"hex/#action","title":"Action","text":"<p>Each action represents the cell index to be filled.</p>"},{"location":"hex/#rewards","title":"Rewards","text":"<p>Non-zero rewards are given only at the terminal states. The reward at terminal state is described in this table:</p> Reward Win <code>+1</code> Lose <code>-1</code>"},{"location":"hex/#termination","title":"Termination","text":"<p>Termination happens when </p> <ol> <li>either one player connect opposite sides of the board, or </li> <li>all <code>121 (= 11 x 11)</code> cells are filled.</li> </ol>"},{"location":"hex/#version-history","title":"Version History","text":"<ul> <li><code>v0</code> : Initial release (v1.0.0)</li> </ul>"},{"location":"othello/","title":"Othello","text":"darklight <p><p> </p></p> <p><p> </p></p>"},{"location":"othello/#usage","title":"Usage","text":"<pre><code>import pgx\nenv = pgx.make(\"othello\")\n</code></pre> <p>or you can directly load <code>Othello</code> class</p> <pre><code>from pgx.othello import Othello\nenv = Othello()\n</code></pre>"},{"location":"othello/#description","title":"Description","text":"<p>Othello, or differing in not having a defined starting position, Reversi, is a two-player zero-sum and perfect information abstract strategy board game, usually played on a board with 8 rows and 8 columns and a set of light and a dark turnable pieces for each side. The player's goal is to have a majority of their colored pieces showing at the end of the game, turning over as many of their opponent's pieces as possible. The dark player makes the first move from the starting position, alternating with the light player. Each player has to place a piece on the board such that there exists at least one straight (horizontal, vertical, or diagonal) occupied line of opponent pieces between the new piece and another own piece. After placing the piece, the side turns over (flips, captures) all opponent pieces lying on any straight lines between the new piece and any anchoring own pieces.</p> <p>Chess Programming Wiki</p>"},{"location":"othello/#specs","title":"Specs","text":"Name Value Version <code>v0</code> Number of players <code>2</code> Number of actions <code>65 (= 8 x 8 + 1)</code> Observation shape <code>(8, 8, 2)</code> Observation type <code>bool</code> Rewards <code>{-1, 0, 1}</code>"},{"location":"othello/#observation","title":"Observation","text":"Index Description <code>[:, :, 0]</code> represents <code>(8, 8)</code> squares colored by the current player <code>[:, :, 1]</code> represents <code>(8, 8)</code> squares colored by the opponent player of current player"},{"location":"othello/#action","title":"Action","text":"<p>Each action (<code>{0, ..., 63}</code>) represents the square index to be filled. The last <code>64</code>-th action represents pass action.</p>"},{"location":"othello/#rewards","title":"Rewards","text":"<p>Non-zero rewards are given only at the terminal states. The reward at terminal state is described in this table:</p> Reward Win <code>+1</code> Lose <code>-1</code> Draw <code>0</code>"},{"location":"othello/#termination","title":"Termination","text":"<p>Termination happens when all <code>64 (= 8 x 8)</code> playable squares are filled.</p>"},{"location":"othello/#version-history","title":"Version History","text":"<ul> <li><code>v0</code> : Initial release (v1.0.0)</li> </ul>"},{"location":"tic_tac_toe/","title":"Tic-tac-toe","text":"darklight <p><p> </p></p> <p><p> </p></p>"},{"location":"tic_tac_toe/#usage","title":"Usage","text":"<pre><code>import pgx\nenv = pgx.make(\"tic_tac_toe\")\n</code></pre> <p>or you can directly load <code>TicTacToe</code> class</p> <pre><code>from pgx.tic_tac_toe import TicTacToe\nenv = TicTacToe()\n</code></pre>"},{"location":"tic_tac_toe/#description","title":"Description","text":"<p>Tic-tac-toe is a paper-and-pencil game for two players who take turns marking the spaces in a three-by-three grid with X or O. The player who succeeds in placing three of their marks in a horizontal, vertical, or diagonal row is the winner. </p> <p>Wikipedia</p>"},{"location":"tic_tac_toe/#specs","title":"Specs","text":"Name Value Version <code>v0</code> Number of players <code>2</code> Number of actions <code>9</code> Observation shape <code>(3, 3, 2)</code> Observation type <code>bool</code> Rewards <code>{-1, 0, 1}</code>"},{"location":"tic_tac_toe/#observation","title":"Observation","text":"Index Description <code>[:, :, 0]</code> represents <code>(3, 3)</code> squares filled by the current player <code>[:, :, 1]</code> represents <code>(3, 3)</code> squares filled by the opponent player of current player"},{"location":"tic_tac_toe/#action","title":"Action","text":"<p>Each action represents the square index to be filled.</p>"},{"location":"tic_tac_toe/#rewards","title":"Rewards","text":"<p>Non-zero rewards are given only at the terminal states. The reward at terminal state is described in this table:</p> Reward Win <code>+1</code> Lose <code>-1</code> Draw <code>0</code>"},{"location":"tic_tac_toe/#termination","title":"Termination","text":"<p>Termination happens when </p> <ol> <li>either one player places three of their symbols in a row (horizontally, vertically, or diagonally), or </li> <li>all nine squares are filled.</li> </ol>"},{"location":"tic_tac_toe/#version-history","title":"Version History","text":"<ul> <li><code>v0</code> : Initial release (v1.0.0)</li> </ul>"}]}